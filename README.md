# Computer Science & Software Engineering - My Self Taught Guide To Becoming A Job-Ready Software Engineer


### Hello World! I'm **Ryan M. Waite** and I'm a software engineer based in Maryland, USA. I graduated in December 2021 with a bachelors of science in computer science from UMGC (University of Maryland Global Campus) and have been working in the tech field since February 2016.


### Although I do have a CS degree now, I learned much of computer science outside of college from various resources: Udacity, Udemy, YouTube, online forums, websites, job experience, former coworkers/managers/leads.


### My tech career/journey starts back in March 2015 when I joined a tech program called **Year Up**. It's a non-profit workforce development program for helping young adults enter the tech field by providing training and internships. During my time there, the program did not teach web development BUT they partnered with another program that did: Udacity. Year Up gave me a scholarship to learn with Udacity, which is an online learning platform; that scholarship was for Udacity's **Front-End Development Nanodegree**, it was the first thing I learned that got me into the field. 


### Over the years, I learned the different areas of programming/software-engineering/computer-science while at work and on my free-time and in a scatters fashion; there was no real order to the things I was learning and I didn't know the things I should know. My second job in Reston, Virginia is what really challenged me and made me realize I didn't know enough to be a solid, skilled software engineer; I was still a novice. In order to stay job relevant and because I loved Computer Science to do so, I decided to go to school for it, despite already being in the field already.


### After finishing my degree (which I did online), I realize that for most colleges, online college classes are no different, and dare I say, no better than other modern courses you would find on platforms like Udacity, Udemy, Coursera, Edx, etc. Had I been on-campus for my core classes where I actually got to build circuit boards and other things, I would have learned and understood the practical side of things more. The honest truth is, these classes teach by just giving you a pdf or some book to read and just take quizzes/exams/projects/labs on; it is heavily theory-based knowledge. There is nothing online college courses teach that you cannot find for free somewhere online that do just a good job teaching, if not better.


### A computer science program equips you with a breadth of skills and knowledge and everything you need to know about computers/computing in order for you to get into any area of computing: web development, game development, mobile app development, internet of things. However, most people get a CS degree just to get a job for web development and work at a junior/mid level, which still pays a considerable amount; it is usually managers or people that have a serious/deep passion that get the degree. The skills in the degree allows you to create/invent/advance the science and body of knowledge of computers and computing, and people aren't doing that at majority of companies because majority of companies don't need that kind of work done for their applications, because much of computing is already established. Computer Scientists create/invent/advance the body of knowledge and machines/tools; software engineers use what is already created/invented to make software applications, and I honestly don't thing a degree is needed for the general use case.

### With that all being said, if i could go back in time to when i first started learning software engineering, this is the order in which  i would learn everything to where everything would make sense and piece together perfectly (I attached links to where you could learn each section header). After learning the core/needed skills, create projects and portfolios and network with people online like linkedin.


The bullet points with an asterisk `*` is considered vital for everyday work as a software engineer and getting that first job; `&` is considered helpful to know and something to be aware of; `%` means is isn't too useful and you can go without as far as getting that first job.



1. ### Quick History (1-2 days)
- What is computer Science and what is a computer? `*`
- main functions of a computer: take in input, remember things, produce an output
- how did/was it created?
- human computers
- analog computers
- digital circuit computer (computing machine)
- turing machine
- punch cards
- transition to modern digital computer
- SUMMARY/KEY TAKE-AWAYS
  - people used to be called computers
  - people made devices/machines to do the computations for us
- RESOURCES:
  - https://cs.uwaterloo.ca/~shallit/Courses/134/history.html
  - https://en.wikipedia.org/wiki/History_of_computer_science
  - https://www.tutorialspoint.com/basics_of_computers/index.htm
- CERTIFICATE COURSES:
  - https://www.coursera.org/learn/how-computers-work
- What to practice:
  - n/a; just get a brief undestanding of the history of numbers and computing


2. ### Discrete Math (4-5 days)
- logic notation `%`
- logic proofs `*`
- permutations `&`
- combinations `&`
- set theory `&`
- graph theory `&`
- tree theory
- matrix theory
- boolean algebra `*`
- boolean logic `&`
- truth tables/karnaugh map `&`
- math functions
- laws for boolean logic 
- SUMMARY/KEY TAKE-AWAYS
  - math based on known information and logical reasoning
  - boolean algebra lets us encode real world expressions into math expressions and instructions
- RESOURCES:
  - https://www.tutorialspoint.com/discrete_mathematics/index.htm
  - https://en.wikipedia.org/wiki/Discrete_mathematics
- CERTIFICATE COURSES:
  - https://study.com/academy/course/math-108-discrete-mathematics.html
  - https://www.coursera.org/learn/mathematics-for-computer-science
  - https://www.udemy.com/topic/discrete-math/
- What to practice:
  - solving truth tables to understand boolean logic: https://webspace.ship.edu/jwcraw/dmrev2dev/Chapter1/1-3-truthTables.html


3. ### Computer Architecture
- number system(s)
- base 2 number system (binary), bits, bytes, etc 
- floating points and fixed points in binary `*`
- signed integer `&`
- how memory works, memory address `*`
- circuit/motherboard, power supply, system bus
- transistors, logic gates
- ROM (Read Only Memory) 
- RAM (Random Access Memory) `*`
- Hard Drive, Cache `*`
- fetching/storing memory (cache-hit, cache-miss) `&`
- Instruction set and Op Code 
- CPU (Central Processing Unit): ALU, CU, Register
- Input/Output
- BIOS
- SUMMARY/KEY TAKE-AWAYS
  - the physical machines that process our math instructions
  - transistors, logic gates, CPU all makes what a computer is
- RESOURCES:
  - https://en.wikipedia.org/wiki/Computer_architecture
  - https://www.sciencedirect.com/topics/computer-science/computer-architecture
- CERTIFICATE COURSES:
  - https://www.edx.org/course/computer-architecture?index=product&queryID=4ceddb1a936ef198297552c9f308d115&position=1
  - https://study.com/academy/course/computer-science-306-computer-architecture.html
  - https://www.udemy.com/course/computer-organization-and-architecture-course-masterclass/
- What to practice:
  - if you want, you can use a program called **Logism** to practice creating your own circuit boards/CPUs/etc - http://www.cburch.com/logisim/


4. ### Programming Intro `*`
- what is programming, what are programming languages and why they exist
- the relation to math and computing (computers use math concepts, like variables)
- data types 
- conditions
- loops
- functions
- programming styles/paradigms (functional, imperative, declarative,  object-oriented, etc)
- bonus: the connection between loops and calculus math (derivative/integrals/summations)
- SUMMARY/KEY TAKE-AWAYS
  - programming is the act of writing instructions for a computer
  - we have programming languages to make writing instructions easier than writing binary
- RESOURCES:
  - https://www.snhu.edu/about-us/newsroom/stem/what-is-computer-programming#:~:text=Computer%20programming%20is%20the%20process,them%20on%20how%20to%20perform.
  - https://en.wikipedia.org/wiki/Computer_programming
- CERTIFICATE COURSES:
  - https://www.coursera.org/learn/introduction-to-computer-programming
  - https://www.edx.org/course/introduction-to-computer-science-and-programming-7?index=product&queryID=da9ac1b037d1d6097ba98aca3a95aac4&position=3
  - https://www.udemy.com/course/the-complete-coding-for-beginners-course/
  - https://study.com/academy/course/computer-science-109-introduction-to-programming.html
- What to practice:
  - practice writing programs in your preferred programming. Most start off with Python since it is the easiest to learn with but i recommend JavaScript and/or Java

5. ### Data Structures `*`
- arrays
- lists/dynamic arrays
- multi-dimensional arrays
- linked-lists
- stacks
- queues
- hash-map (key-value pairs, associative array, dictionary)
- hash-set 
- graph
- tree
- binary tree
- heap
- other data structures 
- SUMMARY/KEY TAKE-AWAYS
  - how data is represented/stored in computer memory
  - different structure help solve different problems/algorithms 
- RESOURCES:
  - https://www.geeksforgeeks.org/data-structures/
- CERTIFICATE COURSES:
  - https://www.edx.org/course/data-structures-fundamentals?index=product&queryID=7149ce17679c1a3b94b29d45389eb270&position=5
  - https://www.udemy.com/course/data-structures-and-algorithms-bootcamp-in-python/
  - https://study.com/academy/course/computer-science-201-data-structures.html
- What to practice:
  - use a programming language and try creating/using each of the data structures. learn about dot notation and bracket notation and working with objects.
  

6. ### Algorithms `*`
- analysis of algorithms: asymptotic
- time and space complexity
- orders of growth
- big omega (lower bound)
- big Oh (upper bound)
- big theta (exact bound)
- type of algorithms (searching and sorting)
- greedy algorithms
- divide and conquer
- recursion
- search traversal (binary-search, etc)
- sorting (quick sort, selection sort, merge sort)
- SUMMARY/KEY TAKE-AWAYS
  - techniques for solving problems
  - time and space requirements/complexity analysis of solutions to problems
- RESOURCES:
  - https://en.wikipedia.org/wiki/Algorithm
  - https://www.geeksforgeeks.org/introduction-to-algorithms/
- CERTIFICATE COURSES:
  - https://www.udemy.com/course/data-structures-and-algorithms-bootcamp-in-python/ 
  - https://www.edx.org/course/data-structures-algorithms-i-arraylists-linkedlists-stacks-and-queues?index=product&queryID=9d7b4df29f303c8389e9b22085818416&position=3
- What to practice:
  - try to memorize the orders of growth from fastest to slowest
  - write programs using different algorithms on different data structures
  - Use sites like LeetCode and AlgoExpert

7. ### Computer Graphics `%`
- GUI (Graphical user interface)
- RGB and pixels
- how graphics are drawn
- SUMMARY/KEY TAKE-AWAYS
  - how a computer draws pixels
- RESOURCES:
  - https://en.wikipedia.org/wiki/Computer_graphics
- CERTIFICATE COURSES:
  - https://www.edx.org/course/computer-graphics-2?index=product&queryID=0e2250dff6825f5ce4e5662b246789fd&position=1
- What to practice:
  - nothing to really practice here

8. ### Programming Language theory & Design `*`
- syntax
- semantics
- run time
- types of languages, history on languages
- activation records
- scopes in programming
- memory address and pointers
- garbage collection
- values and data
- pass by reference, pass by value
- primitives and objects
- static vs dynamic typings
- theory
- SUMMARY/KEY TAKE-AWAYS
  - the idea of how programming languages are designed and how they work 
- RESOURCES:
  - https://en.wikipedia.org/wiki/Programming_language_theory#:~:text=Programming%20language%20theory%20(PLT)%20is,languages%20known%20as%20programming%20languages.
  - https://www.tutorialspoint.com/what-is-an-activation-record
  - http://aleteya.cs.buap.mx/~jlavalle/papers/books_on_line/John%20Wiley%20&%20Sons%20-%20Programming%20Language%20Design%20Concepts.pdf
- CERTIFICATE COURSES:
  - https://www.coursera.org/learn/programming-languages
- What to practice:
  - Try using different languages to get a feel for how it works

9. ### OS (Operating system)
- what is OS and why it's needed
- types of OS and purposes
- processes and threads `*`
- scheduling and interrupts `&`
- multi-processing and CPU cores `*`
- synchronization and dead-lock `*`
- memory management and virtual memory 
- disk management / scheduling, defragmentation `&`
- file management and file system
- peripherals and drivers `&`
- kernal
- unix/linux 
- CLI (command line interface) `*`
- SUMMARY/KEY TAKE-AWAYS
  - the software program that manages physical resources and other software programs
- RESOURCES:
  - https://en.wikipedia.org/wiki/Operating_system
  - https://www.tutorialspoint.com/operating_system/os_overview.htm
  - https://www.geeksforgeeks.org/introduction-of-operating-system-set-1/
- CERTIFICATE COURSES:
  - https://study.com/academy/course/computer-science-105-introduction-to-operating-systems.html
  - https://study.com/academy/course/computer-science-305-operating-systems.html
- What to practice:
  - write programs that use I/O such as network requests or the file system
  - on mac, open Activity Monitor to see live examples of programs
  - on windows, open task managers to see processes, memory and etc

10. ### Compiler `&`
- what is a compiler and why it is needed
- compiler vs. interpretor `*`
- compilation process (tokenization, lexical analysis, semantic analysis, etc) 
- how a compiler is created 
- formal language, grammar and BNF (baukus-naur form)
- yacc and lexx
- SUMMARY/KEY TAKE-AWAYS
  - the program that translate programming languages to machine code/binary
- RESOURCES:
  - https://en.wikipedia.org/wiki/Compiler
  - https://www.geeksforgeeks.org/introduction-of-compiler-design/
- CERTIFICATE COURSES:
  - https://www.edx.org/course/compilers?index=product&queryID=41f7cd7bb7f304f84acdc77c83156684&position=2 
- What to practice:
  - You can try to create your own languate using Flex and Bison

11. ### Computer Science Recap
- computers (computing machine) are basically a bunch of light/electric switches where the order of switches have a specific meaning/instruction


12. ### Computer Networks
- What is a computer network and why?
- OSI model/layers `*`
- how computers connect and communicate (packets, network cards, switches, routers)
- protocols (HTTP, FTP, SMTP, etc) `*`
- http, client/server communication model and how websites work `*`
- application layer of OSI model `*`
- what is a client
- what is a server
- types of servers `&`
- SUMMARY/KEY TAKE-AWAYS
  - computers have hardware and software for connecting and communicating with one another to send/receive instructions
- RESOURCES:
  - https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/
  - https://www.geeksforgeeks.org/layers-of-osi-model/
  - https://en.wikipedia.org/wiki/Computer_network
- What to practice:
  - write a program that makes network requests
  - open the network tab in a Browser's dev tools and analze network requests


13. ### Front-End Web Development: theory, purpose and basics `*`
- what is front end web Development, why
- HTML
- CSS
- JavaScript
- what is a browser
- What to practice:
  - create pages and basic websites with html and css


14. ### Front-End Web Development: Deep Dive `*`
- how the browser works
- how browsers load and process/renders website resources and information (scripts, fonts, html, css, images, videos, etc)
- browser animation frame
- developer tools 
- HTML DOM (Document Object Model; notice how it represents a tree data structure)
- CSS rules; many styles; style overrides; inheritence 
- JavaScript DOM manipulation
- script tag async defer attributes
- speeding up page loads
- web fonts
- accessibility `&`
- UI libraries (bootstrap, bulma, tailwind, materialize/material ui)
- UI Frameworks (Angular, React)
- UI/UX design: principles and fundamentals
- Web peformance
- Debugging front-end problems
- testing with unit tests (Jasmine.JS)
- What to practice:
  - learn a framework like React
  - learn each tab in the dev tools
  - build web pages with ui libraries like bootstrap


15. ### Tools for Development `*`
- version control (git)
- IDEs (VsCode, Intellij, etc)
- software management (homebrew for mac os, chocolately for windows)
- What to practice:
  - install VSCode, Intellij CE and get familiar writing programs in it
  - practice using git on CLI


16. ### Back-End Web Development: theory, purpose and basics `*`
- what is backend and why?
- tools for backend development (database, file system, other servers)
- What to practice:
  - create a demo server program. Python and NodeJS are good options

17. ### Back-End Web Development: Deep Dive `*`
- Languages: Java, Python, JavaScript (Node.js), Ruby, PHP
- Frameworks for web applications: Express.js, Springboot, Django, Ruby on Rails, Laravel
- Routing, Requests and Responses
- static files
- data exchange formats: JSON, XML
- Databases (MySQL, PostgreSQL) intro/fundamentals
- SQL intro/fundamentals
- SQL/Relational vs Non-Relation/NoSQL
- Mongo DB
- Authentication
- Authorization
- Sessions
- Apache and Nginx
- OAuth
- Cryptography
- Web Security (CSRF, CORS, etc)
- APIs & RESTful API design
- What to practice:
  - create a full stack application that uses both front end and back end technologies

18. ### Cloud Services `&`
- what is the "Cloud", the future of cloud technology and services `*`
- top service providers (Amazon Web Services, Microsoft Azure, Google Cloud Platform) 
- Core cloud services `&`
- What to practice:
  - learn about AWS; check out their free tier and use things under the "Always FREE" option/services
 

19. ### Software Engineering: Skills, Technique, Resources `*`
- techniques for writing better code 
- techniques for code organization and reusability
- online resources (books, stackoverflow)
- learn to read documentation and other online forums
- what are tech stacks 
- critical thinking
- planning
- scaling an application
- application Architecture
- Dev Ops
- Work Methodologies (agile, waterfall, etc)
- Testing applications: Behavior-Driven Development (BDD), Selenium, etc
- Jenkins for CI/CD 
- Docker for container applications
- learn how to apply theoretical/prior/foundational knowledge to solve problems
- dependencies concepts: application dependencies on other libraries/platforms/services/frameworks/etc
- understand design decisions 
- What to practice:
  - create projects demonstrating everything you learned; build a portfolio
  - contribute to open source projects/libraries


20. ### Subject Matter Expert (SME) `*`
- understanding the apps and systems you work with and the purpose(s) of them
- using prior knowledge and understanding to figure out solutions to problems
- types of problems: data vs. behavior/functionality
- proper approach to testing and troubleshooting
- What to practice:
  - 





<br>

### General Resources
- https://www.tutorialspoint.com/computer_science_tutorials.htm
- https://www.w3schools.com/
- https://www.geeksforgeeks.org/
- https://developer.mozilla.org/en-US/
- https://www.youtube.com/watch?v=tpIctyqH29Q&list=PLH2l6uzC4UEW0s7-KewFLBC1D0l6XRfye


<br>

### Online Learning Platforms
- https://alison.com/courses?tag=programming&language=en
- https://www.udemy.com/
- http://udacity.com/
- https://www.edx.org/
- https://www.mooc-list.com/

